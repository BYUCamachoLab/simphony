# netlist.py
#
# Dependencies:
#     - numpy
#         Required for cascading s-matrices together.
#     - jsons
#         Similar to GSON in Java, serializes and deserializes custom models.
#         Required to convert the ObjectModelNetlist to a file that can be saved 
#         and read later.
#         API: https://jsons.readthedocs.io/en/latest/index.html
#     - copy
#         Some objects are deep copied during circuit matrix cascading.
#
# This file contains everything related to netlist generation and modeling.

# from simphony.components import BaseComponent, create_component_by_name

import jsons
import json
import copy
import numpy as np
from typing import List#, Tuple

from simphony.core import ComponentModel, ComponentInstance
from simphony.core import connect as rf

# LLNetlist = List[Tuple[ComponentInstance, int, ComponentInstance, int]]

class Netlist:
    """Represents a netlist.

    Has component_set, a set, and instance_list, a list.
    """
    _internal_net = -1
    _external_net = 0

    def __init__(self, components: List[ComponentInstance]=None):

        self.components = [] if components is None else components

    # def get_external_components(self):
    #     return [component for component in self.components if (any(int(x) < 0 for x in component.nets))]

    @classmethod
    def next_internal(cls):
        cls._internal_net = cls._internal_net + 1
        return cls._internal_net

    @classmethod
    def next_external(cls):
        cls._external_net = cls._external_net - 1
        return cls._external_net

    def load(self, data, formatter='ll'):
        """Loads formatted component data into a netlist.

        Parameters
        ----------
        data
            The data to be loaded into the netlist.
        format : str
            Specification for the way the data is formatted.

        'format' can be any one of the following:
        
        =====   =====
        string  description
        -----   -----
        'll'    (list of lists)
        =====   =====
        """
        loader = None
        if formatter == 'll':
            loader = self._ll_loader
        loader(data)

    def _ll_loader(self, connection_list):
        """Loads the netlist with data formatted as a list of lists.

        Format for the data is a list of lists, as follows:
        [[instance_1, port_m, instance_2, port_n],
         [instance_3, port_m, instance_4, port_n],
         [...                                   ]]

        Ports are 0-indexed.
        """
        components = set()

        if type(connection_list) == zip.__class__:
            connection_list = list(connection_list)

        for connection in connection_list:
            c1, p1, c2, p2 = connection
            net_id = self.next_internal()
            c1.nets[p1] = net_id
            c2.nets[p2] = net_id
            components.add(c1)
            components.add(c2)
        
        for component in components:
            component.nets = [net if net is not None else self.next_external() for net in component.nets]

        self.components = list(components)
        for comp in self.components:
            print(comp.model.component_type, comp.nets)


    def toJSON(self) -> str:
        return jsons.dump(self, verbose=True, strip_privates=True)

    @property
    def net_count(self):
        """Returns the number of internal nets in the Netlist.

        Finds the number of internal nets by iterating through the components
        and finding the max net number. Since internal net id's are assigned 
        beginning from '0', the total number of nets is always max(nets) + 1.

        Returns
        -------
        int
            The total count of internal nets.
        """
        # https://stackoverflow.com/a/29244327/11530613
        nets = [net for sublist in [comp.nets for comp in self.components] for net in sublist]
        return max(nets) + 1




def create_component_by_name(comp):
    return None

class ObjectModelNetlist:
    """
    The Parser class reads a netlist generated by the SiEPIC toolbox and uses 
    various classes which inherit from 'models.components.ComponentModel' to create 
    an object based model of a photonic circuit. 
    
    Each derived class is connected to a component model in 'models' that 
    exposes a 'get_s_params' method with its appropriate arguments to the 
    derived model. These s_params are the s-matrices of the component, which 
    are then used to simulate the circuit's transmission behavior.

    Attributes
    ----------
    component_list : list
        A list of objects derived from 'models.components.ComponentModel' 
        representing the photonic circuit.
    net_count : int
        A counter keeping track of the total number of nets in the circuit 
        (0-indexed).
    """

    def __init__(self):
        self.component_list = []
        self.instance_list = []
        self.net_count = 0

    def parse_file(self, filepath: str) -> list:
        """Converts a netlist to an object model of the circuit.

        Parses through the netlist (given a filename) to identify components 
        and organize them into objects. Objects are connected with their data 
        models, allowing them to retrieve any available parameters.

        Parameters
        ----------
        filepath : str
            The name of the file to be parsed.

        Returns
        -------
        component_list : list
            A list of all components found in the netlist, with their 
            accompanying properties and values.
        """
        with open(filepath) as fid:
            text = fid.read()
            return self.parse_text(text)

    def parse_text(self, text: str) -> list:
        """
        Parses the string format of the netlist. Instead of requiring a file, 
        string representations of netlists can also be converted into an object
        model.

        Parameters
        ----------
        text : str
            The text of the netlist.
        
        Returns
        -------
        component_list : list
            A list of all components found in the netlist, with their 
            accompanying properties and values.
        """
        lines = text.splitlines()
        for line in lines:
                elements = line.split()
                if len(elements) > 0:
                    if (".ends" in elements[0]):
                        break
                    elif ("." in elements[0]) or ("*" in elements[0]):
                        continue
                    else:
                        self._parse_line(elements)
        return self.component_list

    def _parse_line(self, line_elements: list):
        """ Parses a line from the netlist, already split into individual 
        elements, and converts it into a new ComponentModel object.

        Reads the elements on a line of the netlist (already delimited before 
        passed to _parse_line) and creates the appropriate object. Appends the 
        newly created object to the Parser's component_list.
        
        Parameters
        ----------
        line_elements : list
            A list of all the elements on a line (already split by some 
            delimiter).
        """

        # TODO: Consider having each component parse its own line, rather than
        # needing to add more case statements if new parameters show up.
        component = None
        nets = []
        for item in line_elements[1:]:
            if "N$" in item:
                net = str(item).replace("N$", '')
                nets.append(net)
                if int(net) > self.net_count:
                    self.net_count = int(net)
                continue
            elif component is None:
                component = create_component_by_name(item)
            elif "lay_x=" in item:
                component.lay_x = float(str(item).replace("lay_x=", ''))
            elif "lay_y=" in item:
                component.lay_y = float(str(item).replace("lay_y=", ''))
            elif "radius=" in item:
                component.radius = float(str(item).replace("radius=", ''))
            elif "wg_length=" in item:
                lenth = str(item).replace("wg_length=", '')
                component.length = strToSci(lenth)
            elif "wg_width=" in item:
                width = str(item).replace("wg_width=", '')
                # Width needs to be stored in microns (um)
                component.width = strToSci(width)*1e6
            elif "points=" in item:
                # The regex, in case you ever need it: /(\[[\d]+[\,][\d]+\])/g
                points = str(item).replace("points=", '')
                points = points.replace("\"[[", '')
                points = points.replace("]]\"", '')
                point_list = points.split('],[')
                for point in point_list:
                    out = point.split(',')
                    component.points.append((float(out[0]), float(out[1])))
        component.nets = nets
        self.component_list.append(component)

    def add_component(self, component):
        self.component_list.append(component)

    def get_external_components(self):
        return [component for component in self.component_list if (any(int(x) < 0 for x in component.nets))]

    def toJSON(self) -> str:
        return jsons.dump(self, verbose=True, strip_privates=True)

    @staticmethod
    def save(filename, netlist):
        with open(filename, 'w') as outfile:
            json.dump(netlist.toJSON(), outfile, indent=2)

    @staticmethod
    def load(filename):
        obj = None
        with open(filename) as jsonfile:
            try:
                data = json.load(jsonfile)
                obj = jsons.load(data)
                obj.component_list = jsons.load(obj.component_list)
                if obj is not None:
                    return obj
                else:
                    raise RuntimeError("Netlist could not load successfully.")
            except:
                raise RuntimeError("Netlist could not load successfully.")
            
        

